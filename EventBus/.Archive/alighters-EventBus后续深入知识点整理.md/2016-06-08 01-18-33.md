# EventBus后续深入知识点整理

来源:[http://alighters.com/blog/2016/05/24/eventbus-3-dot-0-indepth-knowledge/?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io](http://alighters.com/blog/2016/05/24/eventbus-3-dot-0-indepth-knowledge/?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io)

根据上一篇文章[浅析EventBus 3.0实现思想 对EventBus](http://alighters.com/blog/2016/05/22/eventbus3-dot-0-analyze/)的概括，本文针对其中一些重要且比较有意思的知识点，做一下如下的汇总整理 ：

## FindState的妙用

在EventBus中，会根据class信息，来获取**SubscriberMethod**,这里会在**SubscriberMethodFinder**中进行处理，提供了两种方式来进行获取：

* 通过`findUsingInfo(Class<?> subscriberClass)`在apt中进行查找获取
* 使用`findUsingReflection(Class<?> subscriberClass)`方法，进行反射来获取 而在这里，EventBus采用了一个中间器FindState，来看一下它的结构：

```
static class FindState {
    final List<SubscriberMethod> subscriberMethods = new ArrayList<>();

    Class<?> subscriberClass;
    Class<?> clazz;
    boolean skipSuperClasses;
    SubscriberInfo subscriberInfo;
}
```

这里对查找的状态值做了一些封装，其中有订阅类`subscriberClass`,事件对象clazz,以及查找的结果`subscriberMethods`、`subscriberInfo`等，另外，还有一个判断的标志量`skipSuperClasses`，用来标记是否需要进行父类的查看查找。

同时，我们可以看出在使用`EventBus`定义订阅方法的时候，有些通用的逻辑，是可以抽象放置在父类中的。

为什么要使用`FindState`呢？首先是面向对象封装的采用，那么看看它给我们提供了哪些方法？

```
void initForSubscriber(Class<?> subscriberClass) {
    ...
}
boolean checkAdd(Method method, Class<?> eventType) {
    ...
}
private boolean checkAddWithMethodSignature(Method method, Class<?> eventType) {
    ...
}
void moveToSuperclass() {
    ...
}
```

方法中的initForSubscriber是用来初始化传入订阅类的，两个check方法则是用来检查方法信息的，这样用来保证获取的订阅方法都是合法的。moveToSuperClass则是需要查看父类中的订阅方法。这样对方法检查的逻辑，我们就把它们抽象在了FindState中。

## 缓存的使用

使用java的，应该要知道频繁地创建对象，是非常消耗资源的，在jvm垃圾回收时候，会出现内存抖动的问题。所以，我们在这里，一定要注意缓存的使用。

上文中提到的中间器**FindState**，就采用了缓存：

```
private static final int POOL_SIZE = 4;
private static final FindState[] FIND_STATE_POOL = new FindState[POOL_SIZE];
```

指定了FindState的缓存大小为4，并使用一维的静态数组，所以这里需要注意线程同步的问题：

```
private FindState prepareFindState() {
    synchronized (FIND_STATE_POOL) {
        for (int i = 0; i < POOL_SIZE; i++) {
            FindState state = FIND_STATE_POOL[i];
            if (state != null) {
                FIND_STATE_POOL[i] = null;
                return state;
            }
        }
    }
    return new FindState();
}
```

这段是用来获取FindState, 可以看到的是对这段缓存的获取使用了*synchronized*关键字，来将缓存中**FindState**的获取，变为同步块。 而在`subscriberMethod`的获取的同时，则对**FindState**的缓存做了添加的操作，同样是也必须是同步代码块：

```
private List<SubscriberMethod> getMethodsAndRelease(FindState findState) {
     List<SubscriberMethod> subscriberMethods = new ArrayList<>(findState.subscriberMethods);
     findState.recycle();
     synchronized (FIND_STATE_POOL) {
         for (int i = 0; i < POOL_SIZE; i++) {
             if (FIND_STATE_POOL[i] == null) {
                 FIND_STATE_POOL[i] = findState;
                 break;
             }
         }
     }
     return subscriberMethods;
 }
```

另外，**EventBus**也对`subsciberMethod`的获取，也做了缓存的操作，这样进行SubscriberMethod查找的时候，则优先进行缓存的查找：

```
private static final Map<Class<?>, List<SubscriberMethod>> METHOD_CACHE = new ConcurrentHashMap<>();
```

这里，使用的是数据结构是**ConcurrentHashMap**，就可以不必写大量的同步代码块了。

反射类方法的使用

反射虽然是比较浪费性能的，但对我们Java开发者来说，这又是必须掌握的一个技能，现在来熟悉一下EventBus中通过@Subscribe注解对SubscriberMethod的查找：